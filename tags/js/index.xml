<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Js on 🤪</title>
    <link>https://vv13.cn/tags/js/</link>
    <description>Recent content in Js on 🤪</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 16 Apr 2018 00:52:54 +0800</lastBuildDate>
    
	<atom:link href="https://vv13.cn/tags/js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>js继承小结</title>
      <link>https://vv13.cn/posts/js%E7%BB%A7%E6%89%BF%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Mon, 16 Apr 2018 00:52:54 +0800</pubDate>
      
      <guid>https://vv13.cn/posts/js%E7%BB%A7%E6%89%BF%E5%B0%8F%E7%BB%93/</guid>
      <description>重写原型链 初始化父类实例，将实例赋予给子类的原型链，这样一来，新原型不仅具有父类的所有属性和方法，而且内部还有一个__proto__指针指向父类的原型，这种方法称之为类式继承，代码如下：
function SuperClass() {} function SubClass() {} SubClass.prototype = new SuperClass() 使用这类继承需要注意以下特性：
 使用子类创建的实例，constructor会指向父类，这是因为子类prototype被替换为父类的prototype了 引用类型的值会被所有实例共享  借用构造函数 将初始化属性与方法定义在父类中，在子类构造函数中使用call()调用父类的构造函数，这样父类的所有实例方法就会赋予给子类实例，这样可以解决引用类型共享问题：
function SuperClass() {} function SubClass() { SuperClass.call(this) } 如果仅靠借用构造函数，方法在构造函数中定义而非原型链，那么函数复用就无从谈起了，所以说借用构造函数很是很少单独使用的。
组合继承 这种方法结合了以上两种的，核心思想为使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承：
function SuperClass() {} function SubClass() { SuperClass.call(this) } SubClass.prototype = new SuperClass() SubClass.prototype.constructor = SubClass 组合继承避免了以上两种的缺点，因此成为JavaScript最常用的继承模式之一。他的缺点是会调用两次父级的构造函数，一次在初始化父类实例赋予给子类原型时，第二次在执行子类的构造函数时。
原型式继承 它通过创造一个临时的构造函数，基于已有对象的原型链创建新的对象：
function createOjbect(obj) { function F() {} F.prototype = obj return new F() } 本质上是对已有对象进行了一次浅拷贝，这类方法我们现可通过Object.create()来实现。
寄生式继承 寄生式继承指的是在继承函数中，在内部通过某种方式来修改对象，最后再返回此对象，由于过程和工厂函数类似，并不暴露给外部，所以称之为寄生：
function createAnother(obj) { const newObj = Object.</description>
    </item>
    
    <item>
      <title>js事件触发机制</title>
      <link>https://vv13.cn/posts/js-event-trigger/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/js-event-trigger/</guid>
      <description>原理 事件捕获
由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。
事件冒泡
由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。
这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。
addEventListen(event, function, useCapture)添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：
container.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; console.log(&amp;#39;container&amp;#39;), true) child.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; console.log(&amp;#39;child&amp;#39;), true) // 点击child, 输出: container，child container.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; console.log(&amp;#39;container&amp;#39;)) child.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; console.log(&amp;#39;child&amp;#39;)) // 点击child, 输出: child，container 假若还是在两个div中，希望点击子元素时不触发父元素的点击事件，我们就需要用到阻止冒泡的方式：stopPropagation，改写child的方法：
child.addEventListener(&amp;#39;click&amp;#39;, e =&amp;gt; { console.log(&amp;#39;child&amp;#39;) e.stopPropagation() }); 说起了stopPropagation，还有一种方式为preventDefault，它的作用不是用于阻止冒泡，而是阻止浏览器默认行为，如a标签跳转，submit提交等。
还有一种方式称为事件委托，利用冒泡的机制，子元素的点击事件可由父元素委托执行，举个例子，还是如上视图，子元素点击事件删除以后，对父元素做以下定义：
container.addEventListener(&amp;#34;click&amp;#34;, e =&amp;gt; { if (e.target.id === &amp;#39;child&amp;#39;) { console.log(&amp;#39;child&amp;#39;) } }); 可见，当点击子元素依然会输出child，在某些特定场景利用事件委托可节省大量的性能。
明白了上述事件关系，target与currentTarget也就易于理解了，简言之，target指引发出发事件的元素，currentTarget则指事件绑定的元素，如通过点击子元素出发父元素，那么父元素中event对象的target为子元素，而currentTarget为它本身。
示例 在这里有必要谈谈鼠标事件，大家可能知道但不记得的常用鼠标事件有以下四种：
 mouseenter：鼠标进入时触发，不响应子元素冒泡事件 mouseover：鼠标进入时触发，响应子元素冒泡事件 mouseleave：鼠标离开时触发，不响应子元素冒泡事件 mouseout：鼠标离开时触发，响应子元素冒泡事件  让我们举一个实际场景来说明关于冒泡的应该(偷懒不附上详细代码了)：
场景如下：</description>
    </item>
    
    <item>
      <title>什么是函数节流</title>
      <link>https://vv13.cn/posts/throttle/</link>
      <pubDate>Sat, 14 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/throttle/</guid>
      <description>什么是函数节流 避免同一时间函数调用多次，消耗大量的性能，比如resize事件、input事件等，通过设定函数执行时间间隔与延时，来达到优化的效果，应用最多的如lodash的debounce防抖函数了吧。
代码实现 首先通过setTimeout实现一个简单的版本，原理为使用clearTimeout刷新定时器即可：
function throttle(fn, delay, ...args) { let timer = null return function() { clearTimeout(timer) timer = setTimeout(() =&amp;gt; fn.apply(this, args), delay) } } 测试函数：
const log = throttle(console.log, 300, 1) for (let i = 0; i &amp;lt; 100; i++) { log() // 只会打印一次 } 这样的函数有时还无法完成要求，比如在拖拽一个元素时，直接使用此节流函数会造成拖拽的时候无法移动，等拖完了就直接闪到终点去了，因为函数一直在定时器内不断刷新，只有到最后才执行了，因此需要对此函数改进一下，多设定一个参数，即触发的时间间隔，这样即可保证函数的执行频率了。
function throttle(fn, delay, duration, ...args) { let timer = null let tStart return function() { clearTimeout(timer) const cStart = +Date() if (!</description>
    </item>
    
    <item>
      <title>异步编程中的thunk函数</title>
      <link>https://vv13.cn/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/</guid>
      <description>什么是Thunk Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。
写一个简单的函数，用于读取package.json的信息：
fs.readFile(&amp;#39;package.json&amp;#39;, (err, data) =&amp;gt; { if (err) throw err; console.log(data.toString()) }) 在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：
const app = new Koa() app.use(function*(next) { const data = yield readFileThunk(&amp;#39;package.json&amp;#39;) console.log(data) yield next }) function readFileThunk(path, cb) { return function(cb) { fs.readFile(path, (err, data) =&amp;gt; { if (err) throw err cb(null, data.toString()) }) } } app.listen(3000) 通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。Thunk函数将多参数函数替换成了单参数版本，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：
app.use(async(ctx, next) =&amp;gt; { const data = await readFileWrap(&amp;#39;package.json&amp;#39;) console.log(data) await next() }) function readFileWrap(path, cb) { return new Promise((resolve, reject) =&amp;gt; { fs.</description>
    </item>
    
    <item>
      <title>理解javascript线程</title>
      <link>https://vv13.cn/posts/%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 09 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/%E7%90%86%E8%A7%A3javascript%E7%BA%BF%E7%A8%8B/</guid>
      <description>进程和线程  进程：系统资源分配与组织的最小单位，具备独立功能的程序即可成为一个进程，它有自己的内存空间 线程：cpu调度和分派(运行)的最小单位，线程是一个进程的实体，可以共享进程独占的资源，自己只拥有一点在运行中必不可少的资源(程序计数器、寄存器、栈)  线程的作用：
 大多数程序需要多个线程同步或互斥的并行完成工作，将工作分化到线程中简化了编程模型 线程很轻量，创建与销毁消耗的资源小 线程提高了cpu利用率，避免了如等待用户输入、异步资源请求等一系列阻塞操作  根据以上概念，多核cpu可以同时运行多个线程，那可以运行多个进程吗？普遍的答案是cpu只能同时运行一个线程，它是靠时间片轮转来实现的伪多进程，以下有一个关于利用多核心cpu的一个解释：
最早 UNIX 的调度是以 “进程” 为最小调度单位，那个时候还没有线程的概念。线程有两种，一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。 能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。 另外只要资源足够（内存） CPU 可以 hold 住任意多的进程或线程，这与 CPU 的核数无关。你在这里指的应该是 “运行” 。 javascript单线程机制 javascipt语言最大的特点就是单线程，同一时间只有一段代码在执行，这种语言有一个共同的特点：基于事件驱动。它虽然是单线程的，但是所在的平台肯定是异构的：
 在浏览器中，界面渲染线程负责渲染、浏览器事件处理器、异步请求线程等，他们会配合javascript实现各种异步操作。 再node种，libuv库负责node api的执行，它将不同的任务分配给不同的线程，形成一个event loop，以异步的方式将任务的执行结果返回给V8引擎。  所以说，javascript执行是单线程的，方法是异步的，应用是多线程的。
任务队列 javascript核心为单线程机制，所有任务执行都需要按照顺序进行排队，如果前一个任务耗时长，后一个任务就需要等待，因此那些耗时较长的任务就被javascript的作者设计成了异步任务，任务队列正是存放异步任务的地方。
同步任务指在主线程中执行的任务栈，它会形成一个执行栈，像堆积木一样存放，实现层层调用，若有一个任务失败，则整个程序就会失败。异步任务就放到了任务队列里，等到异步任务成功响应(io输入读取完成、异步请求等待到服务器的响应)，任务队列会通知主线程执行预先设定好的回调函数。
任务队列还有时间的概念，通过定时器setTimeout()和setInterval()这两个函数就可以在任务队列中规定多少事件后执行，它们调用后会返回定时器id,通过clearTimeout与clearInterval可以取消。
关于定时器的用法，常见的如setTimeout(fn, 0);，需要注意的是它不会立即执行，而是需要等到主进行这一次所有同步任务执行结束后，才会去读取任务队列的通知，执行相应的定时器方法。
事件循环(Event Loop) Event Loop是一个程序结构，用于等待和发送消息事件，它是javascript单线程的重要处理机制，简单说就是将其他线程的资源取回主线程，执行事先设定的回调函数。
主线程会不断的从消息队列中读取事件，这个过程是不断循环的，因此称之为事件循环，事件循环经常用以下方式实现:
while (queue.waitForMessage()) { queue.processNextMessage() } 而消息队列是一个先进先出的队列，当有异步操作完成或事件点击产生时，回调函数会作为消息进入到消息队列，等待主线程的读取与执行。
Web Worker 随着页面越来越复杂，html5制定了新的标准，而web worker的到来就是为浏览器端提供了多线程的编程能力，允许主线程将一些高计算或高延迟的工作分配给子线程。
Web Worker所执行的代码是在另一个作用域中，与当前代码不共享作用域，也无法访问dom，而且在父子线程中通讯时，传值是被序列化后复制到Worker中的，而不是直接引用传递，这样足以避免子线程影响父线程。</description>
    </item>
    
    <item>
      <title>几个简单的排序-js描述</title>
      <link>https://vv13.cn/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/%E5%86%92%E6%B3%A1%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>排序算法的精髓就在于：不用会忘，看一遍就能懂。 所以记录一下还是很有必要的。
冒泡 冒泡排序（Bubble Sort），是一种较简单的排序算法，较稳定，用途广，时间复杂度为O(n^2)。
原理 此示例一共进行了4次循环，每次确认一个最大的索引值。每进行一次循环时，从索引0开始往下进行比较，若索引0大于索引1则互相交换位置，否则不进行交换，然后接着往下进行比较，保证索引位置始终大于之前找到的数。
代码 function sort(arrs) { const len = arrs.length; for (let i = 0; i &amp;lt; len - 1; i++) { for (let j = 0; j &amp;lt; len - 1 - i; j++) { if ( arrs[j] &amp;gt; arrs[j + 1]) { [arrs[j], arrs[j + 1]] = [arrs[j + 1], arrs[j]]; } } } } 输入：3,6,9,4,2 输出：2,3,4,6,9 耗时：18ms 选择排序 选择排序也很简单，大家懂冒泡就理解，它是冒泡排序的一种改进方法，他们都是每次循环找出一个最大或最小的数，区别在于冒泡排序会进行很多次交换数据，而选择排序用一个变量来暂存值，每趟循环只进行一次交换。
原理 如图所示，每次循环找出最大值，与最小索引进行交换，这样就实现了从大到小的排序。</description>
    </item>
    
    <item>
      <title>BOM对象的应用</title>
      <link>https://vv13.cn/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/bom%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description> BOM即浏览器对象模型，在js代码里，存在一个代表窗体的全局window对象，通过它可以与浏览器进行一定的交互功能，如： + 跳转到新的网址：window.location.href = &#39;http://www.google.com&#39;; + 打开新的窗体：window.open(&#39;http://www.google.com&#39;); + 刷新页面：window.location.reload(); + 后退：window.history.back(); + 前进：window.history.forward();
子窗体与父窗体对象的引用 考虑以下场景：在一个页面中弹出一个子页面，在操作完成后即关闭子页面并刷新父页面。这个场景会在登录页面中十分常见，我们希望当用户登陆完成后刷新父页面，因此需要引用父对象，若在同源页面（浏览器的同源保护策略）即可对子页面进行以下方法的调用：
function dealOk() { window.opener.location.reload(); window.close(); } 若是引入第三方的页面，如qq互联接口，则无法直接通过opener获取到父对象进行操作，我们可以通过轮询子窗体状态进行控制：
// showPopup会返回window对象，原理是window.open()方法的调用 const childrenWindow = QC.Login.showPopup({ appId: APPID, redirectURI: REDIRECT_URI, }); const timer = setInterval(() =&amp;gt; { // 查看窗体是否被关闭 if (childrenWindow.closed) { clearInterval(timer); // 清除轮询 window.location.reload(); // 刷新页面 } },500); a标签阻止其跳转 将a标签的href值设为undefined，就可以阻止其跳转，void函数会执行一个表达式，并只返回undefined，我们也可以通过执行;直接返回undefined：
 &amp;lt;a href=&amp;quot;javascript:void(0);&amp;quot;&amp;gt;点击不会进行跳转&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;quot;javascript:;&amp;quot;&amp;gt;点击不会进行跳转&amp;lt;/a&amp;gt;  </description>
    </item>
    
    <item>
      <title>js代理函数技巧</title>
      <link>https://vv13.cn/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/js%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%8A%80%E5%B7%A7/</guid>
      <description>简述 有时候我们总想改造某些函数，保留它原有的功能与参数，追加新的操作在里面，若是自己写的函数，则直接改写函数即可，但假若是系统给定的函数与未知的参数，那么该怎么办呢？
示例 假设下面有一个自定义函数splice, 它主要的功能是删除原数组指定索引元素，再将其返回：
function splice(arrs, start, length) { arrs.splice(start, length); return arrs; } const arrs = [1,2,3]; splice(arrs, 1, 1); // 返回为：[1,3] 如果我们需要扩展splice，比如打印被删除的元素信息，则只需要进行如下更改：
function splice(arrs, start, length) { console.log(`索引位置：${start}, 长度${length}，元素为：${arrs.splice(start, length)}`); return arrs; } const arrs = [1,2,3]; splice(arrs, 1, 2); // 返回为: [1] // 索引位置：1, 长度2，元素为：2,3 上述方法并不太理想，因为这样一来每次扩展方法都会修改原方法，我们不希望原方法进行修改。splice是es5内置的数组方法，就算想要修改原方法也不行，那么应该怎么做呢？这时候就应该使用代理了:
const arrs = [1,2,3]; const proxy = (...args) =&amp;gt; { const cutArrs = arrs.splice.apply(arrs, args); console.log(`索引位置：${args[0]}, 长度${args[1]}，元素为：${cutArrs}`); } proxy(1, 2); // 索引位置：1, 长度2，元素为：2,3 console.</description>
    </item>
    
    <item>
      <title>js变量申明解析</title>
      <link>https://vv13.cn/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/js%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E%E8%A7%A3%E6%9E%90/</guid>
      <description>var属性有多种需要注意的特性： 1. 无块级作用域 2. 不带申明类型默认为全局变量 3. 变量提升 4. 运行重新申明变量
一、块级作用域 首先，js中申明的var变量或是方法，都没有块级作用域，只有函数作用域，最典型的示例为：
for (var i = 0; i &amp;lt; 100; i++){ // ... } console.log(i); // 输入100 若我们使用es6的let与const，就不会出现这种问题。
二、影响全局 若申明变量不使用变量类型，即使写在另一个函数作用域中申明的变量，也会直接将变量挂载在全局对象上，最容易引发此错误的地方在于使用with的时候，with可以延展一个对象的作用域链，将一个作用域的链拼接到执行上下文的作用域链中，相当于延长了当前作用域链：
const obj = { a: &amp;#39;a&amp;#39;, b: &amp;#39;b&amp;#39;, }; with (obj) { console.log(a, b); // a b b = 3; c = 1; } console.log(obj.b, c); // 3 1 在with作用域中可以直接访问到b的值， 但是我们假如书写错误或是记漏变量名，如对c进行操作，则会创建一个全局变量c，这样不但会污染全局空间，也会对系统造成额外的开销，让我们来测试一段使用with语句进行访问的测试代码:
const testobj = { foo: &amp;#39;bar&amp;#39; }; let value; let starttime; let endtime; const times = 1000000; starttime = new Date().</description>
    </item>
    
    <item>
      <title>js变量作用域与垃圾回收</title>
      <link>https://vv13.cn/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 21 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://vv13.cn/posts/js%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>栈内存与堆内存 js变量分为基本类型与引用类型, 所有变量都储存在函数方法体内,但根据类型的不同实际存储位置不一样.基本类型存储于栈内中,而引用类型存于堆内存中, 我们先来看看什么是堆内存与栈内存.初始化以下代码:
const name = &amp;#39;某某某&amp;#39;; const age = 22; const hasGf = false; const obj = { test: 123, } const anotherObj = obj; 它们在内存中的结构如图：
 栈内存(stack): 如int,string,number等基本变量,他们的大小是固定的,由系统分配栈存储空间 堆内存(heap):对象的属性是动态扩展的,系统并不知道它栈多少空间,因此创建一个对象, 会在堆内存中开辟一个不固定的空间, 然后返回首地址指针给函数内的变量进行引用  由上图即可看出, 对基本类型与引用类型进行值传递也会不一样:
 基本类型直接在栈内存中进行复制值 引用类型只是将堆内存中的索引传递给变量,它们实际指向的是同一个对象  既然涉及到变量的使用与改变, 难免会遇到栈溢出,堆溢出等问题,以下是一个递归的求和函数, 当调用多次,就会发生栈溢出:
function test(n) { if (n === 1) { return 1; } return n + test(n - 1); } test(10000); // 50005000 test(100000); // Uncaught RangeError: Maximum call stack size exceeded(…) 正是因为每个函数栈中限制了大小, 而每次递归调用都会保存着当前函数栈的信息,等待下一函数执行完返回结果, 执行test函数5次,栈空间变化为:</description>
    </item>
    
  </channel>
</rss>