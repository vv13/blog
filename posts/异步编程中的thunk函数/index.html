<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="vv13">
    <meta name="description" content="vv13&#39;s personal website">
    <meta name="keywords" content="blog,developer,personal">

    <base href="https://vv13.cn">
    <title>
  异步编程中的thunk函数 · 🤪
</title>

    <link rel="canonical" href="https://vv13.cn/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84thunk%E5%87%BD%E6%95%B0/">

    <link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700">
    <link rel="stylesheet" href="//cdn.rawgit.com/necolas/normalize.css/master/normalize.css">
    <link rel="stylesheet" href="https://vv13.cn/css/style.min.css">

    

    

    <link rel="icon" type="image/png" href="https://vv13.cn/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://vv13.cn/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.36" />
  </head>

  <body class="">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://vv13.cn">
      🤪
    </a>
    
    <ul class="navigation-list  float-right ">
      
      <li class="navigation-item">
        <a class="navigation-link" href="https://vv13.cn/posts/">Blog</a>
      </li>
      
      <li class="navigation-item">
        <a class="navigation-link" href="https://vv13.cn/about/">About</a>
      </li>
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
  <article>
    <header>
      <h1 class="title">异步编程中的thunk函数</h1>
      <h2 class="date">August 23, 2017</h2>

      
    </header>

    

<h2 id="什么是thunk">什么是Thunk</h2>

<p>Thunk英译即转化程序，第一次遇见这个名词是在使用redux-thunk的时候，只知道是做为异步和同步中间件来使用，并未深入的了解，接下来发现koa的框架中是因在koa1的概念中设计到了它，故学习了一番，因此做一个简单的总结。</p>

<p>写一个简单的函数，用于读取package.json的信息：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">fs.readFile(&#39;package.json&#39;, (err, data) =&gt; {
    if (err) throw err;
    console.log(data.toString())
})</pre></div>
<p>在某些情况下，我们需要将参数进行包装一下，比如在koa1的生成器中间件中，我们必须将函数包装成有且只有一个callback函数，这样koa中间件才能识别函数：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">const app = new Koa()

app.use(function*(next) {
    const data = yield readFileThunk(&#39;package.json&#39;)
    console.log(data)
    yield next
})

function readFileThunk(path, cb) {
    return function(cb) {
        fs.readFile(path, (err, data) =&gt; {
            if (err) throw err
            cb(null, data.toString())
        })
    }
}
app.listen(3000)</pre></div>
<p>通过访问端口，我们看到了正确的打印信息，将正常函数包装为上述函数，即称之为thunk函数。<strong>Thunk函数将多参数函数替换成了单参数版本</strong>，与高阶函数、柯里化思想类似。播个小插曲，在koa2中，中间件写法更迭成了async/await，其原理也是基于generator进行又一次封装，代码为：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">app.use(async(ctx, next) =&gt; {
    const data = await readFileWrap(&#39;package.json&#39;)
    console.log(data)
    await next()
})

function readFileWrap(path, cb) {
    return new Promise((resolve, reject) =&gt; {
        fs.readFile(path, (err, data) =&gt; {
            if (err) throw reject(error)
            resolve(data.toString())
        })
    })
}</pre></div>
<p>我们接下来自己实现一个简易的thunk工具方法，思路如下：</p>

<ol>
<li>一共三个执行函数，第一层函数传入主函数方法fn，并返回一个带有fn方法的闭包</li>
<li>第二层函数传入参数args，然后返回一个仅需传入回调函数供外部执行的方法</li>
<li>第三层函数传入一个回调函数cb, 然后执行主程序</li>
</ol>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">function thunkit(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments) 
        return function(cb) {
            args.push(cb)
            return fn.apply(this, args)
        }
    }
}</pre></div>
<p>在实际使用中，往往业务场景更复杂，因此推荐使用node-thunkify库，源代码也只有28行，请看下一节。</p>

<h2 id="thunkify源码解析">thunkify源码解析</h2>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">function thunkify(fn){
  assert(&#39;function&#39; == typeof fn, &#39;function required&#39;); // 是否为函数

  return function(){
    var args = new Array(arguments.length); 
    var ctx = this; // 绑定函数的上下文对象
	
	// 初始化了一个新的数组，这种写法兼容性更强，不像本文上面直接用的.slice方法进行拷贝数组
    for(var i = 0; i &lt; args.length; ++i) {
      args[i] = arguments[i];
    }

    return function(done){
      var called; // 记录是否执行回调，只允许执行一次

      args.push(function(){
        if (called) return;
        called = true;
        done.apply(null, arguments);
      });

      try {
        fn.apply(ctx, args); // 调用参数列表
      } catch (err) {
        done(err); // 返回错误
      }
    }
  }
};</pre></div>
<p>源代码已经够简单了，想也无需多说明，<strong>重要的是函数本身的思想与灵活的去运用</strong>。</p>

<h3 id="参考资料">参考资料</h3>

<ul>
<li><p><a href="https://github.com/tj/node-thunkify">node-thunkify</a></p></li>

<li><p><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html">阮一峰-Thunk 函数的含义和用法</a></p></li>

<li><p><a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/">experiments-with-koa-and-javascript-generators</a></p></li>
</ul>

  </article>

  <br/>

  
  
</section>

      </div>

      <footer class="footer">
  <section class="container">
     © 2018  
  </section>
</footer>

    </main>

    

  </body>

</html>
