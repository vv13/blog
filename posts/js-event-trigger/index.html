<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="vv13">
    <meta name="description" content="vv13&#39;s personal website">
    <meta name="keywords" content="blog,developer,personal">

    <base href="https://vv13.cn">
    <title>
  js事件触发机制 · 🤪
</title>

    <link rel="canonical" href="https://vv13.cn/posts/js-event-trigger/">

    <link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700">
    <link rel="stylesheet" href="//cdn.rawgit.com/necolas/normalize.css/master/normalize.css">
    <link rel="stylesheet" href="https://vv13.cn/css/style.min.css">

    

    

    <link rel="icon" type="image/png" href="https://vv13.cn/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://vv13.cn/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.36" />
  </head>

  <body class="">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://vv13.cn">
      🤪
    </a>
    
    <ul class="navigation-list  float-right ">
      
      <li class="navigation-item">
        <a class="navigation-link" href="https://vv13.cn/posts/">Blog</a>
      </li>
      
      <li class="navigation-item">
        <a class="navigation-link" href="https://vv13.cn/about/">About</a>
      </li>
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
  <article>
    <header>
      <h1 class="title">js事件触发机制</h1>
      <h2 class="date">October 17, 2017</h2>

      
    </header>

    

<h2 id="原理">原理</h2>

<p><strong>事件捕获</strong></p>

<p>由网景最先提出，事件会从最外层开始发生，直到最具体的元素，也就是说假如父元素与子元素都绑定有点击事件，又互相重叠，那么先出发的会是父元素的事件，然后再传递到子元素。</p>

<p><strong>事件冒泡</strong></p>

<p>由微软提出，事件会从最内从的元素开始发生，再向外传播，正好与事件捕获相反。</p>

<p>这两个概念都是为了解决页面中事件流的发生顺序，w3c采取了折中的办法，制定了统一的标准：先捕获再冒泡。</p>

<hr />

<p><img src="http://7xp5r4.com1.z0.glb.clouddn.com/17-10-17/68340524.jpg" alt="" /></p>

<p><code>addEventListen(event, function, useCapture)</code>添加事件的第三个参数默认值为false，即默认使用事件冒泡，若为true则使用事件捕获的机制，以下为测试代码：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">container.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;container&#39;), true)
child.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;child&#39;), true)
// 点击child, 输出: container，child

container.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;container&#39;))
child.addEventListener(&#39;click&#39;, () =&gt; console.log(&#39;child&#39;))
// 点击child, 输出: child，container</pre></div>
<p>假若还是在两个div中，希望点击子元素时不触发父元素的点击事件，我们就需要用到<strong>阻止冒泡</strong>的方式：<code>stopPropagation</code>，改写child的方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">child.addEventListener(&#39;click&#39;, e =&gt; {
  console.log(&#39;child&#39;)
  e.stopPropagation()
});</pre></div>
<p>说起了stopPropagation，还有一种方式为preventDefault，它的作用不是用于阻止冒泡，而是<strong>阻止浏览器默认行为</strong>，如a标签跳转，submit提交等。</p>

<p>还有一种方式称为<strong>事件委托</strong>，利用冒泡的机制，子元素的点击事件可由父元素委托执行，举个例子，还是如上视图，子元素点击事件删除以后，对父元素做以下定义：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">container.addEventListener(&#34;click&#34;, e =&gt; {
  if (e.target.id === &#39;child&#39;) {
    console.log(&#39;child&#39;)
  }
});</pre></div>
<p>可见，当点击子元素依然会输出<code>child</code>，在某些特定场景利用事件委托可节省大量的性能。</p>

<p>明白了上述事件关系，target与currentTarget也就易于理解了，简言之，<strong>target指引发出发事件的元素，currentTarget则指事件绑定的元素</strong>，如通过点击子元素出发父元素，那么父元素中event对象的target为子元素，而currentTarget为它本身。</p>

<h2 id="示例">示例</h2>

<p>在这里有必要谈谈鼠标事件，大家可能知道但不记得的常用鼠标事件有以下四种：</p>

<ul>
<li>mouseenter：鼠标进入时触发，不响应子元素冒泡事件</li>
<li>mouseover：鼠标进入时触发，响应子元素冒泡事件</li>
<li>mouseleave：鼠标离开时触发，不响应子元素冒泡事件</li>
<li>mouseout：鼠标离开时触发，响应子元素冒泡事件</li>
</ul>

<p>让我们举一个实际场景来说明关于冒泡的应该(偷懒不附上详细代码了)：</p>

<p><img src="http://7xp5r4.com1.z0.glb.clouddn.com/17-10-19/36934899.jpg" alt="" /></p>

<p>场景如下：</p>

<ul>
<li>鼠标移入每一行，显示编辑按钮，移出则取消</li>
<li>点击编辑按钮后，显示输入框，直到点击确定才回到之前的状态</li>
</ul>

<p>其实这个场景看起来简单，不明白事件机制就容易遇到很多坑，毕竟是用原生js写，而不是jquery的解决方案，接下来我来说一下我实现此场景的步骤。</p>

<p>单看页面，其实就是ul&gt;li结构，此场景的条数可能有上千条，我最先考虑到的也是hover机制，但是css hover并不能解决问题，因为点击编辑以后，就不受hover态影响了，因此该编辑与输入框的显示应该由两个元素变量来判断：<code>&lt;div class=&quot;schedule-input-wrap&quot; v-show=&quot;isEdit || hovering&quot;&gt;</code>，也就是说，hover过后hovering为true，点击编辑以后isEdit为true，点击确定以后并移开鼠标此元素才会隐藏。</p>

<p>有了思路，首先考虑<strong>事件捕获机制</strong>，也就是说，我只需要在ul上监听一个mouseover事件，然后通过target.id来判断鼠标移入的是哪个li就行了，但实际情况会比这个复杂，因为子元素也会触发mouseover事件，它会产生冒泡，这样一来，就不能单纯的实现li的hover效果，那怎么办呢？css中有个效果为<code>pointer-events:none;</code>，当我给子元素设置好此属性，结果真的就不冒泡了，能正常显示了，但是这样一来，子元素不仅不会响应mouseover事件，连click事件也不会显示了，因此果断排除掉。</p>

<p>后来的解决方法是在li上添加mouseenter事件，而在ul元素上加mouseleave事件，这样一来，hover态的变量控制就十分完美了，部分代码如下：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">                &lt;ul @mouseleave=&#34;hoverId=&#39;&#39;&#34;&gt;
                    &lt;li v-for=&#34;(item, itemIndex) in record.schedulings&#34;
                        @mouseenter=&#34;hoverId=`item${itemIndex}`&#34;
                        ....
                        &lt;schedule-input :hovering=&#34;isHovering(itemIndex)&#34;
                        &gt;&lt;/schedule-input&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;</pre></div>
<p>其中，hovering的prop用于判定hoverId是否等于当前li的itemIndex。</p>

  </article>

  <br/>

  
  
</section>

      </div>

      <footer class="footer">
  <section class="container">
     © 2018  
  </section>
</footer>

    </main>

    

  </body>

</html>
